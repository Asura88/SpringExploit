package core

import (
	"encoding/json"
	"github.com/SummerSec/SpringExploit/cmd/commons/attack"
	"github.com/SummerSec/SpringExploit/cmd/commons/utils"
	"github.com/fatih/structs"
	log "github.com/sirupsen/logrus"
	"net/url"
)

type Runner struct {
	options *Options
}

func NewRunner(options *Options) (*Runner, error) {
	r := Runner{options: options}

	mops := structs.Map(&r.options)
	data, _ := json.Marshal(mops)
	log.Info("Runner created")
	log.Debug(mops)
	log.Debug("Runner options: ", string(data))
	return &r, nil

}

func (r *Runner) Run() {
	log.Debugln("github.com/SummerSec/SpringExploit/cmd/commons/core/runner.go: Run()")
	log.Info("Runner Running")
	f := r.options.File
	//ip := r.options.IP
	var urls []string
	// TODO: check if options are valid
	//r.options.Url = "http://127.0.0.1:8090/"

	if f == "" {
		urls = append(urls, r.options.Url)
	} else if r.options.File != "" {
		urls, _ = utils.ReadFile(r.options.File)
	} else if r.options.IP != "" {
		urls = utils.GetIPToUrlsLinks(r.options.IP, urls)
	} else {
		log.Error("No file or url or ips specified")
		return
	}

	log.Debugln("URLs: ", urls)
	var i = 0
	k := r.options.Thread
	hashmap := structs.Map(&r.options)
	for i < len(urls) {
		for t := 0; t < k; t++ {
			if i == len(urls) {
				break
			}
			if urls[i] != "" {
				log.Debugln("Running attack on: ", urls[i])
				// 通道通信 发送url 并且 i++
				c := make(chan int)
				go Start(urls[i], hashmap, i, c) // Start k goroutines
				i = <-c
			} else {
				i++
				break
			}
		}
	}

}

func Start(u string, hashmap map[string]interface{}, i int, c chan int) {
	log.Info("Runner started")
	log.Infoln("testing URL: ", u)
	//for k, v := range hashmap {
	//	log.Debugln("key: ", k, " value: ", v)
	//}
	r, err := url.Parse(u)
	if err != nil {
		log.Info("URL parse error")
		log.Errorln(err)
		return
	}
	var target string
	if r.Path == "" {
		target = r.Scheme + "://" + r.Host + "/"
	} else {
		target = r.Scheme + "://" + r.Host + r.Path
	}

	attack.Sevice(target, hashmap)

	// 放到最后，不然无法生效
	c <- i + 1

}
