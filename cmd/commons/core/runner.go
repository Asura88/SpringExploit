package core

import (
	"encoding/json"
	"github.com/SummerSec/SpringExploit/cmd/commons/attack"
	"github.com/SummerSec/SpringExploit/cmd/commons/utils"
	"github.com/fatih/structs"
	"github.com/panjf2000/ants/v2"
	log "github.com/sirupsen/logrus"
	"net/url"
	"sync"
)

type Runner struct {
	options *Options
}

func NewRunner(options *Options) (*Runner, error) {
	r := Runner{options: options}

	mops := structs.Map(&r.options)
	data, _ := json.Marshal(mops)
	log.Debug("Runner created")
	log.Debug(mops)
	log.Debug("Runner options: ", string(data))
	return &r, nil

}

func (r *Runner) Run() {
	log.Info("Starting SpringExploit")
	log.Debug("Runner Running")
	//ip := r.options.IP
	var urls []string
	// TODO: check if options are valid
	//r.options.Url = "http://127.0.0.1:8090/"

	if r.options.Url != "" {
		urls = append(urls, r.options.Url)
	} else if r.options.File != "" {
		urls, _ = utils.ReadFile(r.options.File)
	} else if r.options.IP != "" {
		urls = utils.GetIPToUrlsLinks(r.options.IP, urls)
	} else if r.options.Update {
		selfUpdate()
	} else if r.options.Version {
		getLatestVersion()
		return
	} else if r.options.SP {
		return
	} else {
		log.Error("No file or url or ips specified")
		return
	}

	log.Debugln("URLs  Numbers: ", len(urls))
	var i = 0
	k := r.options.Thread
	var wg sync.WaitGroup
	hashmap := structs.Map(&r.options)
	defer ants.Release()
	// TODO: check if options are valid
	if k <= 0 {
		k = 500
	}
	log.Info("Running with ", k, " threads")
	pool, err1 := ants.NewPool(k+1, ants.WithPreAlloc(true))
	if err1 != nil {
		log.Error("Error creating pool")
		return
	}
	log.Info("Total URLs: ", len(urls))
	for i < len(urls) {
		//TODO 老代码
		//for t := 0; t < k; t++ {
		//	if i == len(urls) {
		//		break
		//	}
		//	if urls[i] != "" {
		//		log.Debugln("Running attack on: ", urls[i])
		//		// 通道通信 发送url 并且 i++
		//		c := make(chan int)
		//		wg.Add(1)
		//		go func() {
		//			log.Debugf("Running go func() %d", t)
		//			Start(urls[i], hashmap, i, c) // Start k goroutines
		//			wg.Done()
		//		}()
		//		i = <-c
		//	} else {
		//		wg.Wait()
		//		i++
		//		break
		//	}
		//}

		for t := 0; t < k; t++ {
			if i == len(urls)-1 {
				break
			}
			if urls[i] != "" {
				// 通道通信 发送url 并且 i++
				//c := make(chan int)
				log.Debugf("Now Threads: %d", t)
				wg.Add(1)
				err := pool.Submit(func() {
					log.Debugf("Running Submit %d url is  %s %d", t, urls[i], i)
					Start2(urls[i], hashmap, i) // Start k goroutines
					wg.Done()
				})
				i++
				if err != nil {
					log.Error("Error submitting job " + urls[i])
					log.Error(err)
				}
				//i = <-c
			} else {
				i++
				wg.Wait()
			}
		}

	}

}

func Start(u string, hashmap map[string]interface{}, i int, c chan int) {
	log.Info("Runner started")
	log.Infoln("Pen-testing URL: ", u)
	//for k, v := range hashmap {
	//	log.Debugln("key: ", k, " value: ", v)
	//}
	r, err := url.Parse(u)
	if err != nil {
		log.Info("URL parse error")
		log.Errorln(err)
		return
	}
	var target string
	if r.Path == "" {
		target = r.Scheme + "://" + r.Host + "/"
	} else {
		target = r.Scheme + "://" + r.Host + r.Path
	}
	attack.Sevice(target, hashmap)
	defer func() {
		if errs := recover(); errs != nil {
			log.Debug("Runner panic: ", errs)
		}
	}()
	// 放到最后，不然无法生效
	c <- i + 1

}

func Start2(u string, hashmap map[string]interface{}, i int) {
	log.Infof("%s Runner started", u)
	//log.Infoln("testing URL: ", u)
	//for k, v := range hashmap {
	//	log.Debugln("key: ", k, " value: ", v)
	//}
	defer func() {
		if errs := recover(); errs != nil {
			log.Debug(errs)
		}
	}()

	r, err := url.Parse(u)
	if err != nil {
		log.Info("URL parse error")
		log.Errorln(err)
		return
	}
	var target string
	if r.Path == "" {
		target = r.Scheme + "://" + r.Host + "/"
	} else {
		target = r.Scheme + "://" + r.Host + r.Path
	}
	attack.Sevice(target, hashmap)
	log.Infof("%s Runner finished", u)

}
